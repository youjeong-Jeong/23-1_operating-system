## 5장 CPU 스케쥴링

#### 2.3 스케쥴링 타입: 선점 스케쥴링과 비선점 스케쥴링

- 비선점 스케쥴링
  - CPU를 더이상 사용할 수 없게 된 경우 : I/O로 인한 블록 상태, sleep()
  - 자발적 CPU 양보 : yield() 시스템 호출
  - 스레드 종료
  - 스케쥴링 알고리즘
    - FCFS : 선입 선처리
      - 큐에 먼저 도착한 스레드를 먼저 스케쥴링
    - SJF : 최단 작업 우선 스케쥴링
      - 실행시간이 가장 짧은 스레드를 우선 선택
    - priority : 가장 높은 우선순위의 스레드를 선택
      - 더 높은 순위의 스레드가 도착할 때, 현재 실행 중인 스레드가 종료한 후 스케줄링 하게되면 비선점 스케줄링
    - MLQ : 스레드들을 n개의 우선순위 레벨로 구분하고 레벨이 높은 스레드를 우선 처리
      - 스레드가 종료할 때 스케줄링 하도록 구현하면 비선점 스케줄링



- 선점 스케쥴링 : 현재 실행 중인 스레드를 강제로 중단

  - 타임 슬라이스가 소진 되었을 때

  - 인터럽트나 시스템 호출 종료 시점에서 더 높은 우선 순위의 스레드가 대기상태에 있을 때

  - **현재 대부분의 운영체제는 선점 스케쥴링을 함**

  - 스케쥴링 알고리즘

    - SRTF : 최소 잔여시간 우선 스케쥴링
      - SFJ의 선점 스케쥴링 버전
      - 남은 시간이 가장 짧은 스레드를 우선 스케줄
    - RR : 라운드 로빈
      - 스레드들에게 공평한 실행 기회를 주기 위함
      - 스레드들을 타임슬라이스 주기로 돌아가면서 선택
    - priority : 가장 높은 우선순위의 스레드를 선택
      - 철저히 우선순위에 따라 스레드를 실행시키려는 목적
      - 더 높은 순위의 스레드가 도착할 때, 현제 스레드를 중단하고 도착한 스레드를 실행 시키면 선점 스케줄링

    - MLQ : 스레드들을 n개의 우선순위 레벨로 구분하고 레벨이 높은 스레드를 우선 처리
      - 현재 스레드의 실행을 중단하고 새로 도착한 스레드를 스케줄하면 선점 스케줄링
    - MLQF : CPU burst가 짧은 스레드나 I/O 작업이 많은 스레드, 혹은 대화식 스레드를 우선 실행시
      - MLQ의 기아 문제를 해결하기 위해 등장
      - 스레드를 다른 레벨을 큐로 이동시키는것이 가능



#### 4.2 멀티 코어 시스템에서 CPU 스케줄링과 작업 분배

##### 싱글 코어 CPU에서 사용하는 스케줄링 기법을 멀티 코어 CPU에서 그대로 사용하면 다음과 같은 2가지 문제 발생

- 컨텍스트 스위칭 후 오버헤드 증가
- 코어별 부하 불균형



##### 컨텍스트 스위칭 후 오버헤드 - 코어 친화성으로 해결

- 실행시키기로 결정된 스레드가 이전에 이 코어에서 실행된 적이 없다면, 새 스레드의 코드와 데이터가 캐시에 적재되는데 적잖은 시간이 걸림
  - 스레드를 동일한 코어에서만 계속 실행되도록 스케줄하는 CPU 친화성으로 문제 해결

##### 코어별 부하 불균형 - 부하 균등화 기법으로 해결

- 스레드를 무작위로 스케줄링 한다면 어떤 코어는 많은 수의 스레드를 실행하고 어떤 코어는 적은 수의 스레드를 실행하게 되어 **코어 사이의 부하불균형**이 초래됨
  - 다음과 같은 부화 균등화 기법을 사용해 해결
    - 푸시 마이그레이션
    - 풀 마이그레이션